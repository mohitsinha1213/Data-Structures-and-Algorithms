class Solution(object):
    
    def editDistance(self, word1, word2, n, m, dp):

        if m == 0:             ### if m is finished that means n is left and you have to delete the remaining n to match both words and it will take n(size of remaining word1) deletion operation.
            return n
        if n == 0:             ### if n is finished that means m is left and you have to insert the remaining m to match both words and it will take m(size of remaining word2) insertion operation.
            return m    

        if dp[n][m] != -1:
            return dp[n][m]

        if word1[n-1] == word2[m-1]:
            dp[n][m] = self.editDistance(word1, word2, n-1, m-1, dp)
            return dp[n][m]
        
        else:
            insertion = 1 + self.editDistance(word1, word2, n, m-1, dp)    ### n will stay at its orginal place and hypothetically you will insert char and n-1 and m-1 happens but its originally n and it will become m-1 and this takes 1 Operation
            
            deletion = 1 +  self.editDistance(word1, word2, n-1, m, dp)    ### if you delete then n moves to n-1 and hypothetically m moves to m-1 but original position of m is same only i.e. m and this takes 1 Operation
            replace = 1 + self.editDistance(word1, word2, n-1, m-1, dp)     ### if you replace the char with correct char both will match and move to n-1 and m-1 and this takes 1 Operation

            dp[n][m] =  min(insertion, deletion, replace)   ### you need find minimum of all possitble operations performed
            return dp[n][m]

    
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        n = len(word1)
        m = len(word2)
        dp = [[-1 for _ in range(m+1)]for _ in range(n+1)]
        return self.editDistance(word1, word2, n, m, dp)


        for i in range(n+1):
            for j in range(m+1):
                if i == 0:
                    dp[i][j] = j
                if j == 0:
                    dp[i][j] = i

        for i in range(n+1):
            for j in range(m+1):

                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1])

        return dp[n][m]                

