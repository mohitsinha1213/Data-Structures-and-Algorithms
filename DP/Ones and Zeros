class Solution(object):
    
    def coutBinary(self, strs, m, n, size, dp):
        if size == 0:
            return 0
        
        if dp[size][m][n] != -1:
            return dp[size][m][n]
        
        count0 = strs[size-1].count('0')
        count1 = strs[size-1].count('1')

        if count0 <= m and count1 <= n:          # We Will Not Take If Count0 <= M Or Count1 <= N:   Because We Will Either Select Complete String Or Select Nothing

            take = 1 + self.coutBinary(strs, m - count0, n - count1, size - 1, dp)
            nottake = self.coutBinary(strs, m, n, size - 1, dp)

            dp[size][m][n] = max(take, nottake)
            return dp[size][m][n]

        else:
            dp[size][m][n] = self.coutBinary(strs, m, n, size - 1, dp)

            return dp[size][m][n]
    
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        
        """
        L = len(strs)
        dp = [[[-1 for _ in range(n+1)] for _ in range(m+1)] for _ in range(L+1)] 
        return self.coutBinary(strs, m, n, L, dp)
                     
