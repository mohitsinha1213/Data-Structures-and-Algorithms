#You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

#Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

#You may assume that you have an infinite number of each kind of coin.


class Solution(object):
    
    def coinAmount(self, coins, amount, n, dp):

        if amount == 0:
            return 0
        if n == 0:
            return float("inf")    # if amount is still left and all coins are considered we return infinite as its impossible.
        
        if dp[n][amount] != -1:
            return dp[n][amount]

        if coins[n-1] <= amount:

            take = 1 + self.coinAmount(coins, amount - coins[n-1], n, dp)
            nottake = self.coinAmount(coins, amount, n-1, dp)
            dp[n][amount] = min(take, nottake)
            return dp[n][amount]

        else:
            dp[n][amount] = self.coinAmount(coins, amount, n-1, dp) 
            return  dp[n][amount]

    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
           
        
        n = len(coins)
        dp = [[-1 for _ in range(amount+1)]for _ in range(n+1)]
        result = self.coinAmount(coins, amount, n, dp)

        return -1 if result == float("inf") else result
